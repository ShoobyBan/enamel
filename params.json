{"name":"Enamel","tagline":"Helps C development with Clay config framework","body":"# Enamel\r\nEnamel is a python script that generates C helpers from a [Clay](https://github.com/pebble/clay) configuration file to easily get the value of your settings.\r\n\r\nEnamel will :\r\n* handle AppMessages automatically (app_message_open, handler registration, ...)\r\n* save/load the value of the settings in the persistant storage automatically\r\n* provide a getter for each of your settings\r\n\r\nYou can focus on your watchapp/face, Enamel will do the rest !\r\n\r\n---\r\n\r\n# Getting Started (pebble wscript)\r\n1. You project must contain a valid configuration file in `src/js/config.json` (see https://github.com/pebble/clay)\r\n2. Extract [Enamel](https://github.com/gregoiresage/enamel/releases/latest) at the root of your Pebble project or create a git submodule\r\n3. Copy and paste the following line into the top of your `wscript` : \r\n  \r\n  ``` python\r\n  from enamel.enamel import enamel\r\n  ```\r\n4. Change the `build` of your wscript from \r\n\r\n  ``` python\r\n  ctx.pbl_program(source=ctx.path.ant_glob('src/**/*.c'), target=app_elf)\r\n  ```\r\n  to\r\n  ``` python\r\n  ctx(rule = enamel, source='src/js/config.json', target=['enamel.c', 'enamel.h'])\r\n  ctx.pbl_program(source=ctx.path.ant_glob('src/**/*.c') + ['enamel.c'], target=app_elf)\r\n  ```\r\n5. Launch your Pebble build : 2 files (enamel.c and enamel.h) should be generated in `build` and compiled\r\n\r\n# Getting Started (python)\r\nIf you can't modify the wscript (Cloudpebble development) you can call directly the python script.<br>\r\nThe following command will generate 2 files (enamel.c and enamel.h) in `src/generated`, you just need to copy them in your project\r\n```\r\npython enamel.py --appinfo /path/to/your/appinfo.json --config /path/to/your/config.json \r\n```\r\n\r\nCall `python enamel.py --help` for help\r\n\r\n---\r\n\r\n# Using Enamel\r\n1. Setup your project correctly for Clay : https://github.com/pebble/clay\r\n2. Include `enamel.h` in your c file : \r\n  \r\n  ``` c\r\n  #include \"enamel.h\"\r\n  ```\r\n3. Initialize enamel in your `init` function : \r\n  \r\n  ``` c\r\n  static void init(void) {\r\n    // Initialize Enamel to register App Message handlers and restores settings\r\n    enamel_init(0, 0);\r\n    \r\n    ...\r\n  }\r\n  ```\r\n4. Deinitialize enamel in your `deinit` function :\r\n  \r\n  ``` c\r\n  static void deinit(void) {\r\n    ...\r\n  \r\n    // Deinit Enamel to unregister App Message handlers and save settings\r\n    enamel_deinit();\r\n  }\r\n  ```\r\n5. (Optional) Register a custom `in_received_handler` in your `init`. <br>This handler will be automatically called by enamel when a setting is received.\r\n\r\n  ``` c\r\n  static void in_received_handler(DictionaryIterator *iter, void *context) {\r\n    APP_LOG(0, \"Settings received %d\", get_myinteger());\r\n    window_set_background_color(window, get_background());\r\n    // do what you want here \r\n    // you will probably udpate your textlayers, colors, ... with the new settings\r\n    // and mark your layers dirty\r\n  }\r\n  \r\n  ...\r\n  \r\n  static void init(void) {\r\n    // Initialize Enamel to register App Message handlers and restores settings\r\n    enamel_init(0, 0);\r\n\r\n    // Register our custom receive handler\r\n    enamel_register_custom_inbox_received(in_received_handler);\r\n    \r\n    ...\r\n  }\r\n  ```\r\n6. Get the value of your setting with :\r\n  \r\n  ``` c\r\n  get_Mysetting(); // where 'Mysetting' is an appKey in your configuration file\r\n  ```\r\n\r\n---\r\n\r\n# Enamel API\r\n\r\n## Methods\r\n\r\n| Method | Description |\r\n|--------|---------|\r\n| `void enamel_init(const uint32_t size_inbound, const uint32_t size_outbound)` | Initialize Enamel. <br>If `size_inbound` is `0`, Enamel will calculate the inbound size automatically for you |\r\n| `void enamel_deinit()` | Deinitialize Enamel and save the settings in the persistant storage |\r\n| `void enamel_register_custom_inbox_received( AppMessageInboxReceived received_callback )` | Register a custom received callback called when a setting is received |\r\n| `<type> get_appKeyId()` | Return the value for the setting `appKeyId` |\r\n\r\n## Type mapping\r\n\r\n| Clay Type | Type returned by the getter |\r\n|--------|---------|\r\n| `heading/text/input` | `char*` |\r\n| `toggle` | `bool` |\r\n| `color` | `GColor` |\r\n| `select/radiogroup` | `char*` or `enum` |\r\n| `checkboxgroup` | not supported |\r\n\r\n### Special case for `select` and `radiogroup`\r\n\r\nIf the value of the options are `string` in the `config.json`, Enamel will generate a `char*` getter\r\n\r\nIf the value of the options are `integer`, Enamel will generate an `enum` mapping all the possible values for this setting and the getter will return this `enum`\r\n\r\nFor the given setting :\r\n``` json\r\n{\r\n  \"type\": \"radiogroup\",\r\n  \"appKey\": \"favorite_food\",\r\n  \"label\": \"Favorite Food\",\r\n  \"defaultValue\": \"1\",\r\n  \"options\": [\r\n    { \r\n      \"label\": \"Sushi\", \r\n      \"value\": 0 \r\n    },\r\n    { \r\n      \"label\": \"Pizza\", \r\n      \"value\": 1 \r\n    },\r\n    { \r\n      \"label\": \"Burgers\", \r\n      \"value\": 2 \r\n    }\r\n  ]\r\n}\r\n```\r\n\r\nEnamel will generate\r\n\r\n``` c\r\ntypedef enum {\r\n\tFAVORITE_FOOD_SUSHI = 0,\r\n\tFAVORITE_FOOD_PIZZA = 1,\r\n\tFAVORITE_FOOD_BURGER = 2,\r\n} FAVORITE_FOODValue;\r\nFAVORITE_FOODValue get_favorite_food();\r\n```\r\n\r\nYou can then easily code switch case for this setting\r\n``` c\r\nswitch(get_favorite_food()){\r\n case FAVORITE_FOOD_SUSHI : break; //do something\r\n case FAVORITE_FOOD_PIZZA : break; //do something\r\n case FAVORITE_FOOD_BURGER : break; //do something\r\n}\r\n```\r\n","google":"UA-44039387-7","note":"Don't delete this file! It's used internally to help with page regeneration."}